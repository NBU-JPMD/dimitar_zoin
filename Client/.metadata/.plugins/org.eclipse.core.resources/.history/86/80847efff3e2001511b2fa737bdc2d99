import java.io.IOException;
import java.net.InetAddress;
import java.net.InetSocketAddress;
import java.net.Socket;
import java.nio.*;
import java.nio.channels.SelectionKey;
import java.nio.channels.Selector;
import java.nio.channels.ServerSocketChannel;
import java.nio.channels.SocketChannel;
import java.nio.channels.spi.SelectorProvider;
import java.util.Iterator;
import java.util.Set;

public class Server implements Runnable {

	private InetAddress hostAddress;
	private int port;

	private ServerSocketChannel servSoCh; 
	private Selector selector;
	private ByteBuffer buf = ByteBuffer.allocate(1024);

	public Server(InetAddress hostAddress, int port) throws IOException {
		this.hostAddress = hostAddress;
		this.port = port;
		this.selector = this.initSelector();
	}

	private Selector initSelector() throws IOException {

		Selector socketSelector = Selector.open();
		this.servSoCh = ServerSocketChannel.open();
		servSoCh.configureBlocking(false);


		InetSocketAddress isa = new InetSocketAddress(this.hostAddress,
				this.port);
		servSoCh.socket().bind(isa);


		servSoCh.register(socketSelector, SelectionKey.OP_ACCEPT);

		return socketSelector;
	}

	public void run() {
		while (true) {
			try {

				this.selector.select();

				Iterator<SelectionKey> selectedKeys = this.selector.selectedKeys().iterator();
				while (selectedKeys.hasNext()) {
					SelectionKey key = (SelectionKey) selectedKeys.next();
					selectedKeys.remove();

					if (!key.isValid()) {
						continue;
					}

					if (key.isAcceptable()) {
						this.accept(key);
					} else if (key.isReadable()) {
						this.read(key);
					}
				}
			} catch (Exception e) {
				e.printStackTrace();
			}
		}
	}

	private void accept(SelectionKey key) throws IOException {

		ServerSocketChannel serverSocketChannel = (ServerSocketChannel) key.channel();

		SocketChannel socketChannel = serverSocketChannel.accept();
		// Socket socket = socketChannel.socket();
		socketChannel.configureBlocking(false);

		// Register the new SocketChannel with our Selector, indicating
		// we'd like to be notified when there's data waiting to be read
		socketChannel.register(this.selector, SelectionKey.OP_READ);
	}
	
	 private void read(SelectionKey key) throws IOException {
		    SocketChannel socketChannel = (SocketChannel) key.channel();

		    // Clear out our read buffer so it's ready for new data
		    this.readBuffer.clear();
		    
		    // Attempt to read off the channel
		    int numRead;
		    try {
		      numRead = socketChannel.read(this.readBuffer);
		    } catch (IOException e) {
		      // The remote forcibly closed the connection, cancel
		      // the selection key and close the channel.
		      key.cancel();
		      socketChannel.close();
		      return;
		    }

		    if (numRead == -1) {
		      // Remote entity shut the socket down cleanly. Do the
		      // same from our end and cancel the channel.
		      key.channel().close();
		      key.cancel();
		      return;
		    }

		    // Hand the data off to our worker thread
		    this.worker.processData(this, socketChannel, this.readBuffer.array(), numRead); 
		  }

	public static void main(String[] args) throws Exception {
		try {
			new Thread(new Server(null, 9090)).start();
		} catch (IOException e) {
			e.printStackTrace();
		}

		
	}
}
